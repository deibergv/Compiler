/* ---------------Seccion de declaraciones preliminares--------------------*/
package com.language.parser;

/* Importaciones  */
import java_cup.runtime.*;
import java.io.FileReader;

/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */
parser code {:
/* Reporte de error encontrado. */
public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error");
    if (info instanceof java_cup.runtime.Symbol) {
        java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
        if (s.left >= 0) {
            m.append(" in line "+(s.left+1));
            if (s.right >= 0)
                m.append(", column "+(s.right+1));
        }
    }
    m.append(" : "+message);
    System.err.println(m);
}

/* Cuando se encuentra un error de donde el sistema no puede
    recuperarse, se lanza un error fatal. Se despliega el mensaje
    de error y se finaliza la ejecucion. */
public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    System.exit(1);
}

/* Metodo main para garantizar la ejecucion del analizador
   lexico y sintactico, ademas que se pase como parametro la tabla
   de simbolos correspondiente. */
public static void main(String[] args){
    try {
        Parser asin = new Parser(
                new Scanner( new FileReader(args[0])));
        Object result = asin.parse().value; //parseo de datos
        System.out.println("\n*** Resultados finales ***");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}
:};

/* ------------Declaracion de simbolos terminales y no terminales---------- */

/* ***Terminales (tokens obtenidos por el analizador lexico).***
   Terminales que no tienen un valor son listados primero, los terminales que
   tienen un valor como los enteros son listados luego.*/
terminal         VAR,SET,ADD,LESS,CHANGEDIR,PLACE,BLOCK,HIGH,PUT,LIGHT,POS,
                  KEEP,SKIP,KEND,FOR,ID,TIMES,FEND,WHEN,THEN,WHEND,POSSTART,
                  CALL,LPAREN,RPAREN,PUNTOCOMA,ASSIGN,AGGREGATE,REDUCED,COMA,
                   LEFT,RIGHT,BACK,SAME,BEGIN,END,PROC,EndPROC;
// No usados: LPARENCUAD,RPARENCUAD

terminal String      IDENTIFIER;
terminal Integer     NUMBER;

/* ***No terminales usados en la seccion gramatical.***
   Primero se lista los no terminales que tienen un valor Object y despues
   se lista los no terminales que tienen un entero. Un Object se refiere a que
   no tienen tipo, pudiendo ser entero o String. */
non terminal Object     root, expr_list, expr_part;
non terminal String     expr;
non terminal Integer    dato;


/* -------------Seccion de predencia y asociacion de los terminales----------- */

/*
  Precedencia de los no terminales, no sirve con simbolos terminales.
  Por eso no la usamos. Además indica si se asocia a izquierda o derecha.
*/
  /*precedence left OP_SUMA, OP_RESTA;
  precedence left OP_MULT;*/


/* ------------------- Seccion de la gramatica ------------------------ */

/* 'expr_list' es la raiz de la gramatica. Una 'expr_list' puede ser una 'expr_list'
   seguida de una expr_part, o puede ser una expr_part.
   Un terminal o no terminal se define <termino> ::= termino1 termino2 ... terminoN.;
   donde termino puede ser terminal o no terminal, solo se permite un simbolo a la
   izquierda. La | sirve para indicar que es una produccion u otra.
   Debemos pasar de simbolos no terminales a simbolos terminales. Una gramatica que no
   termina en simbolos terminales se dice que no reduce, y por lo tanto nunca se finaliza
   su procesado.
*/

expr_list   ::= expr_list expr_part
              |
                expr_part
              ;
/* 'expr_part' se compone de una "expr" seguida de PUNTOCOMA, o de una "asign" seguida de PUNTOCOMA.
   "asign:a" esta estableciendo que "a" representa al objeto asociado a "asign", entre {: :}
   se coloca el codigo en java para las acciones a tomar al cumplirse una produccion.
*/

expr_part   ::= VAR expr:e
               {:
                 System.out.println("Nueva variable con nombre: " + e);
               :}
                PUNTOCOMA
              | VAR expr:e ASSIGN dato:d
               {:
                 System.out.println("Nueva variable con nombre: " + e +
                  " y valor: " + d);
               :}
                PUNTOCOMA
              | SET expr:e ASSIGN dato:d
               {:
                 System.out.println("La variable a modificar tiene el nombre: "
                  + e + " y el valor cambiará a: " + d);
               :}
                PUNTOCOMA
              | ADD AGGREGATE expr:e
               {:
                 System.out.println("Se agregará 1 a la variable: " + e);
               :}
                PUNTOCOMA
              | LESS REDUCED expr:e
               {:
                 System.out.println("Se quitará 1 a la variable: " + e);
               :}
                PUNTOCOMA
              | CHANGEDIR LPAREN LEFT RPAREN
               {:
                 System.out.println("Cambiando direccion a LEFT");
               :}
                PUNTOCOMA
              | CHANGEDIR LPAREN RIGHT RPAREN
               {:
                 System.out.println("Cambiando direccion a RIGHT");
               :}
                PUNTOCOMA
              | CHANGEDIR LPAREN BACK RPAREN
               {:
                 System.out.println("Cambiando direccion a BACK");
               :}
                PUNTOCOMA
              | CHANGEDIR LPAREN SAME RPAREN
               {:
                 System.out.println("Cambiando direccion a SAME");
               :}
                PUNTOCOMA
              | PLACE BLOCK
               {:
                 System.out.println("Se colocará un bloque en la direccion actual");
               :}
                PUNTOCOMA
              | PLACE BLOCK dato:d
               {:
                 System.out.println("Se colocará " + d +
                 " bloques en la direccion actual");
               :}
                PUNTOCOMA
              | HIGH BLOCK
               {:
                 System.out.println("Se colocará un bloque lvl2 en la posicion actual");
               :}
                PUNTOCOMA
              | HIGH BLOCK dato:d
               {:
                 System.out.println("Se colocará un bloques lvl" + d +
                 " en la posicion actual");
               :}
                PUNTOCOMA
              | PUT LIGHT
               {:
                 System.out.println("Se colocará una luz azul en la posicion actual");
               :}
                PUNTOCOMA
              | POS LPAREN expr:x COMA expr:y RPAREN
               {:
                 System.out.println("Cambiando a celda posicion: (" + x + "," + y + ")");
               :}
                PUNTOCOMA
              | POSSTART LPAREN expr:x COMA expr:y RPAREN
               {:
                 System.out.println("Posicion inicial: (" + x + ","+ y + ")");
               :}
                PUNTOCOMA
              | CALL expr:e
               {:
                 System.out.println("Llamando al procedimiento: " + e);
               :}
                PUNTOCOMA
                // FALTA KEEP, FOR y WHEN
             ;

/* 'expr' puede ser una expresion que inicia por "numero entero" "op_suma" "expr",
  de esa forma se realiza una suma. Tambien puede ser un numero entero, con esto
  se devuelve el valor del entero. En RESULT se almacena el valor de las acciones,
  y se pasa al siguiente nivel de la gramatica.
*/

expr        ::=  IDENTIFIER:n
               {:
                 RESULT = n;
               :}
              ;
dato       ::=  NUMBER:n
               {:
                 RESULT = n;
               :}
              ;
